<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Producer on Documentation of php-simple-kafka-client</title><link>https://php-kafka.github.io/php-simple-kafka-client.github.io/producer/</link><description>Recent content in Producer on Documentation of php-simple-kafka-client</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 27 Dec 2020 22:09:37 +0100</lastBuildDate><atom:link href="https://php-kafka.github.io/php-simple-kafka-client.github.io/producer/index.xml" rel="self" type="application/rss+xml"/><item><title>setOauthBearerToken</title><link>https://php-kafka.github.io/php-simple-kafka-client.github.io/producer/setOAuthBearerToken/</link><pubDate>Tue, 07 Sep 2021 10:09:37 +0100</pubDate><guid>https://php-kafka.github.io/php-simple-kafka-client.github.io/producer/setOAuthBearerToken/</guid><description>Description public function setOAuthBearerToken(string $token, int $lifetimeMs, string $principalName, ?array $extensions = null): void {} The SASL/OAUTHBEARER token refresh callback or event handler should invoke
this method upon success. The extension keys must not include the reserved
key auth, and all extension keys and values must conform to the required
format as per https://tools.ietf.org/html/rfc7628#section-3.1
Example $conf = new SimpleKafkaClient\Configuration(); $conf-&amp;gt;set(&amp;#39;metadata.broker.list&amp;#39;, getenv(&amp;#39;TEST_KAFKA_BROKERS&amp;#39;)); $conf-&amp;gt;set(&amp;#39;security.protocol&amp;#39;, &amp;#39;SASL_PLAINTEXT&amp;#39;); $conf-&amp;gt;set(&amp;#39;sasl.mechanisms&amp;#39;, &amp;#39;OAUTHBEARER&amp;#39;); $conf-&amp;gt;set(&amp;#39;sasl.oauthbearer.config&amp;#39;, &amp;#39;principalClaimName=azp&amp;#39;); $conf-&amp;gt;setOAuthBearerTokenRefreshCb(function($kafka, $oAuthBearerConfig) { // get the refresh token with some custom code, then act accordingly if ($tokenRefreshWasSucessful) { $kafka-&amp;gt;setOAuthBearerToken($token, $lifetimeMs, $principalName, $extensions); } else { $kafka-&amp;gt;setOAuthBearerTokenFailure($errorReason); } });</description></item><item><title>setOauthBearerTokenFailure</title><link>https://php-kafka.github.io/php-simple-kafka-client.github.io/producer/setOAuthBearerTokenFailure/</link><pubDate>Tue, 07 Sep 2021 10:09:37 +0100</pubDate><guid>https://php-kafka.github.io/php-simple-kafka-client.github.io/producer/setOAuthBearerTokenFailure/</guid><description>Description public function setOauthBearerTokenFailure(string $errorString): void {} The SASL/OAUTHBEARER token refresh callback or event handler should invoke
this method upon failure. $errorString should be a human readable error reason
why acquiring a token failed.
Example $conf = new SimpleKafkaClient\Configuration(); $conf-&amp;gt;set(&amp;#39;metadata.broker.list&amp;#39;, getenv(&amp;#39;TEST_KAFKA_BROKERS&amp;#39;)); $conf-&amp;gt;set(&amp;#39;security.protocol&amp;#39;, &amp;#39;SASL_PLAINTEXT&amp;#39;); $conf-&amp;gt;set(&amp;#39;sasl.mechanisms&amp;#39;, &amp;#39;OAUTHBEARER&amp;#39;); $conf-&amp;gt;set(&amp;#39;sasl.oauthbearer.config&amp;#39;, &amp;#39;principalClaimName=azp&amp;#39;); $conf-&amp;gt;setOAuthBearerTokenRefreshCb(function($kafka, $oAuthBearerConfig) { // get the refresh token with some custom code, then act accordingly if ($tokenRefreshWasSucessful) { $kafka-&amp;gt;setOAuthBearerToken($token, $lifetimeMs, $principalName, $extensions); } else { $kafka-&amp;gt;setOAuthBearerTokenFailure($errorReason); } });</description></item><item><title>__construct</title><link>https://php-kafka.github.io/php-simple-kafka-client.github.io/producer/__construct/</link><pubDate>Sun, 27 Dec 2020 22:09:37 +0100</pubDate><guid>https://php-kafka.github.io/php-simple-kafka-client.github.io/producer/__construct/</guid><description>Description public function __construct(Configuration $configuration) {} Get a producer instance
Example $conf = SimpleKafkaClient\Configuration(); $conf-&amp;gt;set(&amp;#39;metadata.broker.list&amp;#39;, &amp;#39;kafka:9092&amp;#39;); $producer = new SimpleKafkaClient\Producer($conf);</description></item><item><title>abortTransaction</title><link>https://php-kafka.github.io/php-simple-kafka-client.github.io/producer/abortTransaction/</link><pubDate>Sun, 27 Dec 2020 22:09:37 +0100</pubDate><guid>https://php-kafka.github.io/php-simple-kafka-client.github.io/producer/abortTransaction/</guid><description>Description public function abortTransaction(int $timeoutMs): void {} This function should also be used to recover from non-fatal abortable transaction errors.
Any outstanding messages will be purged and fail with RD_KAFKA_RESP_ERR__PURGE_INFLIGHT or RD_KAFKA_RESP_ERR__PURGE_QUEUE.
Example $conf = SimpleKafkaClient\Configuration(); $conf-&amp;gt;set(&amp;#39;metadata.broker.list&amp;#39;, &amp;#39;kafka:9092&amp;#39;); $producer = new SimpleKafkaClient\Producer($conf); try { $producer-&amp;gt;initTransactions(10000); } catch (SimpleKafkaClient\KafkaErrorException $e) { if ($e-&amp;gt;$transactionRequiresAbort()) { $producer-&amp;gt;abortTransaction(10000); } }</description></item><item><title>beginTransaction</title><link>https://php-kafka.github.io/php-simple-kafka-client.github.io/producer/beginTransaction/</link><pubDate>Sun, 27 Dec 2020 22:09:37 +0100</pubDate><guid>https://php-kafka.github.io/php-simple-kafka-client.github.io/producer/beginTransaction/</guid><description>Description public function beginTransaction(): void {} SimpleKafkaClient\Producer::initTransactions() must have been called successfully (once)
before this function is called. Any messages produced, offsets sent, etc,
after the successful return of this function will be part of the transaction
and committed or aborted automatically.
Finish the transaction by calling SimpleKafkaClient\Producer::commitTransaction()
or abort the transaction by calling SimpleKafkaClient\Producer::abortTransaction()
$conf = SimpleKafkaClient\Configuration(); $conf-&amp;gt;set(&amp;#39;metadata.broker.list&amp;#39;, &amp;#39;kafka:9092&amp;#39;); $producer = new SimpleKafkaClient\Producer($conf); $producer-&amp;gt;initTransactions(10000); $producer-&amp;gt;beginTransaction(); // produce some messsages $producer-&amp;gt;commitTransaction(10000);</description></item><item><title>commitTransaction</title><link>https://php-kafka.github.io/php-simple-kafka-client.github.io/producer/commitTransaction/</link><pubDate>Sun, 27 Dec 2020 22:09:37 +0100</pubDate><guid>https://php-kafka.github.io/php-simple-kafka-client.github.io/producer/commitTransaction/</guid><description>Description public function commitTransaction(int $timeoutMs): void {} Commit the current transaction (as started with SimpleKafkaClient\Producer::beginTransaction()).
Any outstanding messages will be flushed (delivered) before actually committing the transaction.
If any of the outstanding messages fail permanently the current transaction will enter the
abortable error state and this function will return an abortable error, in this case the
application must call SimpleKafkaClient\Producer::abortTransaction() before attempting a new
transaction with SimpleKafkaClient\Producer::beginTransaction().
Example $conf = SimpleKafkaClient\Configuration(); $conf-&amp;gt;set(&amp;#39;metadata.</description></item><item><title>flush</title><link>https://php-kafka.github.io/php-simple-kafka-client.github.io/producer/flush/</link><pubDate>Sun, 27 Dec 2020 22:09:37 +0100</pubDate><guid>https://php-kafka.github.io/php-simple-kafka-client.github.io/producer/flush/</guid><description>Description public function flush(int $timeoutMs): int {} Wait until all outstanding produce requests, et.al, are completed.
This should typically be done prior to destroying a producer instance to make sure
all queued and in-flight produce requests are completed before terminating.
This function will call poll() and thus trigger callbacks.
Example $conf = SimpleKafkaClient\Configuration(); $conf-&amp;gt;set(&amp;#39;metadata.broker.list&amp;#39;, &amp;#39;kafka:9092&amp;#39;); $producer = new SimpleKafkaClient\Producer($conf); // produce some messsages $producer-&amp;gt;flush(10000);</description></item><item><title>getMetadata</title><link>https://php-kafka.github.io/php-simple-kafka-client.github.io/producer/getMetadata/</link><pubDate>Sun, 27 Dec 2020 22:09:37 +0100</pubDate><guid>https://php-kafka.github.io/php-simple-kafka-client.github.io/producer/getMetadata/</guid><description>Description function getMetadata(bool $allTopics, int $timeoutMs, ConsumerTopic $topic = null): Metadata {} Get metadata for all topics or a single topic
Example $conf = SimpleKafkaClient\Configuration(); $conf-&amp;gt;set(&amp;#39;metadata.broker.list&amp;#39;, &amp;#39;kafka:9092&amp;#39;); $producer = new SimpleKafkaClient\Producer($conf); $topicHandle = $producer-&amp;gt;getTopicHandle(&amp;#39;test-topic&amp;#39;); $singleTopicMetadata = $producer-&amp;gt;metadata(true, $topicHandle, 10000);</description></item><item><title>getTopicHandle</title><link>https://php-kafka.github.io/php-simple-kafka-client.github.io/producer/getTopicHandle/</link><pubDate>Sun, 27 Dec 2020 22:09:37 +0100</pubDate><guid>https://php-kafka.github.io/php-simple-kafka-client.github.io/producer/getTopicHandle/</guid><description>Description public function getTopicHandle(string $topic): ConsumerTopic {} Get a topic handle for a given topic name. A topic handle is needed
for example to query metadata from the broker
Example $conf = SimpleKafkaClient\Configuration(); $conf-&amp;gt;set(&amp;#39;metadata.broker.list&amp;#39;, &amp;#39;kafka:9092&amp;#39;); $producer = new SimpleKafkaClient\Producer($conf); $topicHandle = $producer-&amp;gt;getTopicHandle(&amp;#39;test-topic&amp;#39;); // use the topic handle for further calls, e.g. to query metadata $singleTopicMetadata = $producer-&amp;gt;metadata(true, $topicHandle, 10000);</description></item><item><title>initTransactions</title><link>https://php-kafka.github.io/php-simple-kafka-client.github.io/producer/initTransactions/</link><pubDate>Sun, 27 Dec 2020 22:09:37 +0100</pubDate><guid>https://php-kafka.github.io/php-simple-kafka-client.github.io/producer/initTransactions/</guid><description>Description public function initTransactions(int $timeoutMs): void {} Initialize transactions for the producer instance.
This function ensures any transactions initiated by previous instances of
the producer with the same transactional.id are completed.
If the previous instance failed with a transaction in progress the previous
transaction will be aborted. This function needs to be called before any other
transactional or produce functions are called when the transactional.id is configured.
Example $conf = SimpleKafkaClient\Configuration(); $conf-&amp;gt;set(&amp;#39;metadata.</description></item><item><title>offsetsForTimes</title><link>https://php-kafka.github.io/php-simple-kafka-client.github.io/producer/offsetForTimes/</link><pubDate>Sun, 27 Dec 2020 22:09:37 +0100</pubDate><guid>https://php-kafka.github.io/php-simple-kafka-client.github.io/producer/offsetForTimes/</guid><description>Description public function offsetsForTimes(array $topicPartitions, int $timeoutMs): array {} Look up the offsets for the given partitions by timestamp.
The returned offset for each partition is the earliest offset whose
timestamp is greater than or equal to the given timestamp in the
corresponding partition.
Example $conf = SimpleKafkaClient\Configuration(); $conf-&amp;gt;set(&amp;#39;metadata.broker.list&amp;#39;, &amp;#39;kafka:9092&amp;#39;); $producer = new SimpleKafkaClient\Producer($conf); $topicPartition = new TopicPartition(&amp;#39;test-topic&amp;#39;, 0, strtotime(&amp;#34;-1 week&amp;#34;)); $offsetsOneWeekAgo = $producer-&amp;gt;offsetForTimes([$topicPartition], 10000);</description></item><item><title>poll</title><link>https://php-kafka.github.io/php-simple-kafka-client.github.io/producer/poll/</link><pubDate>Sun, 27 Dec 2020 22:09:37 +0100</pubDate><guid>https://php-kafka.github.io/php-simple-kafka-client.github.io/producer/poll/</guid><description>Description public function poll(int $timeoutMs): int {} Polls for events, provided callbacks will be called accordingly
Example $conf = SimpleKafkaClient\Configuration(); $conf-&amp;gt;set(&amp;#39;metadata.broker.list&amp;#39;, &amp;#39;kafka:9092&amp;#39;); $producer = new SimpleKafkaClient\Producer($conf); // produce some messsages $producer-&amp;gt;poll(0); The producer needs to call poll at regular intervals to serve any queued callbacks
waiting to be called, otherwise the internal queue fill up and block the producer.</description></item><item><title>purge</title><link>https://php-kafka.github.io/php-simple-kafka-client.github.io/producer/purge/</link><pubDate>Sun, 27 Dec 2020 22:09:37 +0100</pubDate><guid>https://php-kafka.github.io/php-simple-kafka-client.github.io/producer/purge/</guid><description>Description public function purge(int $purgeFlags): int {} Purges messages handled by the producer.
The application will need to call poll() or flush() afterwards
to serve the delivery report callbacks of the purged messages.
Messages purged from internal queues fail with the delivery report error code
set to RD_KAFKA_RESP_ERR__PURGE_QUEUE, while purged messages that are in-flight
to or from the broker will fail with the error code set to RD_KAFKA_RESP_ERR__PURGE_INFLIGHT.
Purge flags RD_KAFKA_PURGE_F_QUEUE purge internal queue RD_KAFKA_PURGE_F_INFLIGHT purge messages in-flight to or from the broker RD_KAFKA_PURGE_F_NON_BLOCKING make the call non-blocking Example $conf = SimpleKafkaClient\Configuration(); $conf-&amp;gt;set(&amp;#39;metadata.</description></item><item><title>queryWatermarkOffsets</title><link>https://php-kafka.github.io/php-simple-kafka-client.github.io/producer/queryWatermarkOffsets/</link><pubDate>Sun, 27 Dec 2020 22:09:37 +0100</pubDate><guid>https://php-kafka.github.io/php-simple-kafka-client.github.io/producer/queryWatermarkOffsets/</guid><description>Description public function queryWatermarkOffsets(string $topic, int $partition, int &amp;amp;$low, int &amp;amp;$high, int $timeoutMs): void {} Query broker for low (oldest) and high (newest) offsets for a partition
Example $low = 0; $high = 0; $conf = SimpleKafkaClient\Configuration(); $conf-&amp;gt;set(&amp;#39;metadata.broker.list&amp;#39;, &amp;#39;kafka:9092&amp;#39;); $producer = new SimpleKafkaClient\Producer($conf); $topicPartition = new TopicPartition(&amp;#39;test-topic&amp;#39;, 0, strtotime(&amp;#34;-1 week&amp;#34;)); $producer-&amp;gt;queryWatermarkOffsets(&amp;#39;test-topic&amp;#39;, 0, int &amp;amp;$low, int &amp;amp;$high, 10000);</description></item></channel></rss>