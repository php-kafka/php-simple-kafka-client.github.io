<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Producer on Documentation of php-simple-kafka-client</title><link>https://php-kafka.github.io/producer/</link><description>Recent content in Producer on Documentation of php-simple-kafka-client</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 27 Dec 2020 22:09:37 +0100</lastBuildDate><atom:link href="https://php-kafka.github.io/producer/index.xml" rel="self" type="application/rss+xml"/><item><title>__construct</title><link>https://php-kafka.github.io/producer/__construct/</link><pubDate>Sun, 27 Dec 2020 22:09:37 +0100</pubDate><guid>https://php-kafka.github.io/producer/__construct/</guid><description>Description public function __construct(Configuration $configuration) {} Get a producer instance
Example $conf = Kafka\Configuration(); $conf-&amp;gt;set(&amp;#39;metadata.broker.list&amp;#39;, &amp;#39;kafka:9092&amp;#39;); $producer = new Kafka\Producer($conf);</description></item><item><title>abortTransaction</title><link>https://php-kafka.github.io/producer/abortTransaction/</link><pubDate>Sun, 27 Dec 2020 22:09:37 +0100</pubDate><guid>https://php-kafka.github.io/producer/abortTransaction/</guid><description>Description public function abortTransaction(int $timeoutMs): void {} This function should also be used to recover from non-fatal abortable transaction errors.
Any outstanding messages will be purged and fail with RD_KAFKA_RESP_ERR__PURGE_INFLIGHT or RD_KAFKA_RESP_ERR__PURGE_QUEUE.
Example $conf = Kafka\Configuration(); $conf-&amp;gt;set(&amp;#39;metadata.broker.list&amp;#39;, &amp;#39;kafka:9092&amp;#39;); $producer = new Kafka\Producer($conf); try { $producer-&amp;gt;initTransactions(10000); } catch (Kafka\KafkaErrorException $e) { if ($e-&amp;gt;$transactionRequiresAbort()) { $producer-&amp;gt;abortTransaction(10000); } }</description></item><item><title>beginTransaction</title><link>https://php-kafka.github.io/producer/beginTransaction/</link><pubDate>Sun, 27 Dec 2020 22:09:37 +0100</pubDate><guid>https://php-kafka.github.io/producer/beginTransaction/</guid><description>Description public function beginTransaction(): void {} Kafka\Producer::initTransactions() must have been called successfully (once)
before this function is called. Any messages produced, offsets sent, etc,
after the successful return of this function will be part of the transaction
and committed or aborted automatically.
Finish the transaction by calling Kafka\Producer::commitTransaction()
or abort the transaction by calling Kafka\Producer::abortTransaction()
$conf = Kafka\Configuration(); $conf-&amp;gt;set(&amp;#39;metadata.broker.list&amp;#39;, &amp;#39;kafka:9092&amp;#39;); $producer = new Kafka\Producer($conf); $producer-&amp;gt;initTransactions(10000); $producer-&amp;gt;beginTransaction(); // produce some messsages $producer-&amp;gt;commitTransaction(10000);</description></item><item><title>commitTransaction</title><link>https://php-kafka.github.io/producer/commitTransaction/</link><pubDate>Sun, 27 Dec 2020 22:09:37 +0100</pubDate><guid>https://php-kafka.github.io/producer/commitTransaction/</guid><description>Description public function commitTransaction(int $timeoutMs): void {} Commit the current transaction (as started with Kafka\Producer::beginTransaction()).
Any outstanding messages will be flushed (delivered) before actually committing the transaction.
If any of the outstanding messages fail permanently the current transaction will enter the
abortable error state and this function will return an abortable error, in this case the
application must call Kafka\Producer::abortTransaction() before attempting a new
transaction with Kafka\Producer::beginTransaction().
Example $conf = Kafka\Configuration(); $conf-&amp;gt;set(&amp;#39;metadata.</description></item><item><title>flush</title><link>https://php-kafka.github.io/producer/flush/</link><pubDate>Sun, 27 Dec 2020 22:09:37 +0100</pubDate><guid>https://php-kafka.github.io/producer/flush/</guid><description>Description public function flush(int $timeoutMs): int {} Wait until all outstanding produce requests, et.al, are completed.
This should typically be done prior to destroying a producer instance to make sure
all queued and in-flight produce requests are completed before terminating.
This function will call poll() and thus trigger callbacks.
Example $conf = Kafka\Configuration(); $conf-&amp;gt;set(&amp;#39;metadata.broker.list&amp;#39;, &amp;#39;kafka:9092&amp;#39;); $producer = new Kafka\Producer($conf); // produce some messsages $producer-&amp;gt;flush(10000);</description></item><item><title>getMetadata</title><link>https://php-kafka.github.io/producer/getMetadata/</link><pubDate>Sun, 27 Dec 2020 22:09:37 +0100</pubDate><guid>https://php-kafka.github.io/producer/getMetadata/</guid><description>Description function getMetadata(bool $allTopics, int $timeoutMs, ConsumerTopic $topic = null): Metadata {} Get metadata for all topics or a single topic
Example $conf = Kafka\Configuration(); $conf-&amp;gt;set(&amp;#39;metadata.broker.list&amp;#39;, &amp;#39;kafka:9092&amp;#39;); $producer = new Kafka\Producer($conf); $topicHandle = $producer-&amp;gt;getTopicHandle(&amp;#39;test-topic&amp;#39;); $singleTopicMetadata = $producer-&amp;gt;metadata(true, $topicHandle, 10000);</description></item><item><title>getTopicHandle</title><link>https://php-kafka.github.io/producer/getTopicHandle/</link><pubDate>Sun, 27 Dec 2020 22:09:37 +0100</pubDate><guid>https://php-kafka.github.io/producer/getTopicHandle/</guid><description>Description public function getTopicHandle(string $topic): ConsumerTopic {} Get a topic handle for a given topic name. A topic handle is needed
for example to query metadata from the broker
Example $conf = Kafka\Configuration(); $conf-&amp;gt;set(&amp;#39;metadata.broker.list&amp;#39;, &amp;#39;kafka:9092&amp;#39;); $producer = new Kafka\Producer($conf); $topicHandle = $producer-&amp;gt;getTopicHandle(&amp;#39;test-topic&amp;#39;); // use the topic handle for further calls, e.g. to query metadata $singleTopicMetadata = $producer-&amp;gt;metadata(true, $topicHandle, 10000);</description></item><item><title>initTransactions</title><link>https://php-kafka.github.io/producer/initTransactions/</link><pubDate>Sun, 27 Dec 2020 22:09:37 +0100</pubDate><guid>https://php-kafka.github.io/producer/initTransactions/</guid><description>Description public function initTransactions(int $timeoutMs): void {} Initialize transactions for the producer instance.
This function ensures any transactions initiated by previous instances of
the producer with the same transactional.id are completed.
If the previous instance failed with a transaction in progress the previous
transaction will be aborted. This function needs to be called before any other
transactional or produce functions are called when the transactional.id is configured.
Example $conf = Kafka\Configuration(); $conf-&amp;gt;set(&amp;#39;metadata.</description></item><item><title>offsetsForTimes</title><link>https://php-kafka.github.io/producer/offsetForTimes/</link><pubDate>Sun, 27 Dec 2020 22:09:37 +0100</pubDate><guid>https://php-kafka.github.io/producer/offsetForTimes/</guid><description>Description public function offsetsForTimes(array $topicPartitions, int $timeoutMs): array {} Look up the offsets for the given partitions by timestamp.
The returned offset for each partition is the earliest offset whose
timestamp is greater than or equal to the given timestamp in the
corresponding partition.
Example $conf = Kafka\Configuration(); $conf-&amp;gt;set(&amp;#39;metadata.broker.list&amp;#39;, &amp;#39;kafka:9092&amp;#39;); $producer = new Kafka\Producer($conf); $topicPartition = new TopicPartition(&amp;#39;test-topic&amp;#39;, 0, strtotime(&amp;#34;-1 week&amp;#34;)); $offsetsOneWeekAgo = $producer-&amp;gt;offsetForTimes([$topicPartition], 10000);</description></item><item><title>poll</title><link>https://php-kafka.github.io/producer/poll/</link><pubDate>Sun, 27 Dec 2020 22:09:37 +0100</pubDate><guid>https://php-kafka.github.io/producer/poll/</guid><description>Description public function poll(int $timeoutMs): int {} Polls for events, provided callbacks will be called accordingly
Example $conf = Kafka\Configuration(); $conf-&amp;gt;set(&amp;#39;metadata.broker.list&amp;#39;, &amp;#39;kafka:9092&amp;#39;); $producer = new Kafka\Producer($conf); // produce some messsages $producer-&amp;gt;poll(0); The producer needs to call poll at regular intervals to serve any queued callbacks
waiting to be called, otherwise the internal queue fill up and block the producer.</description></item><item><title>purge</title><link>https://php-kafka.github.io/producer/purge/</link><pubDate>Sun, 27 Dec 2020 22:09:37 +0100</pubDate><guid>https://php-kafka.github.io/producer/purge/</guid><description>Description public function purge(int $purgeFlags): int {} Purges messages handled by the producer.
The application will need to call poll() or flush() afterwards
to serve the delivery report callbacks of the purged messages.
Messages purged from internal queues fail with the delivery report error code
set to RD_KAFKA_RESP_ERR__PURGE_QUEUE, while purged messages that are in-flight
to or from the broker will fail with the error code set to RD_KAFKA_RESP_ERR__PURGE_INFLIGHT.
Purge flags RD_KAFKA_PURGE_F_QUEUE purge internal queue RD_KAFKA_PURGE_F_INFLIGHT purge messages in-flight to or from the broker RD_KAFKA_PURGE_F_NON_BLOCKING make the call non-blocking Example $conf = Kafka\Configuration(); $conf-&amp;gt;set(&amp;#39;metadata.</description></item><item><title>queryWatermarkOffsets</title><link>https://php-kafka.github.io/producer/queryWatermarkOffsets/</link><pubDate>Sun, 27 Dec 2020 22:09:37 +0100</pubDate><guid>https://php-kafka.github.io/producer/queryWatermarkOffsets/</guid><description>Description public function queryWatermarkOffsets(string $topic, int $partition, int &amp;amp;$low, int &amp;amp;$high, int $timeoutMs): void {} Query broker for low (oldest) and high (newest) offsets for a partition
Example $low = 0; $high = 0; $conf = Kafka\Configuration(); $conf-&amp;gt;set(&amp;#39;metadata.broker.list&amp;#39;, &amp;#39;kafka:9092&amp;#39;); $producer = new Kafka\Producer($conf); $topicPartition = new TopicPartition(&amp;#39;test-topic&amp;#39;, 0, strtotime(&amp;#34;-1 week&amp;#34;)); $producer-&amp;gt;queryWatermarkOffsets(&amp;#39;test-topic&amp;#39;, 0, int &amp;amp;$low, int &amp;amp;$high, 10000);</description></item></channel></rss>